{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "/Users/kevin/Development/MapCreator/geojson2svg/node_modules/multigeojson/index.js",
    "/Users/kevin/Development/MapCreator/geojson2svg/src/converter.js",
    "/Users/kevin/Development/MapCreator/geojson2svg/src/extend.js",
    "/Users/kevin/Development/MapCreator/geojson2svg/src/instance.js",
    "/Users/kevin/Development/MapCreator/geojson2svg/src/main.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzLA;AACA;AACA;AACA;AACA;AACA",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "//index.js \n(function() { \n\tvar singles = ['Point', 'LineString', 'Polygon'];\n\tvar multies = ['MultiPoint', 'MultiLineString', 'MultiPolygon'];\n\tfunction explode(g) {\n\t  if( multies.indexOf(g.type) > -1) {\n\t    return g.coordinates.map(function(part) {\n\t      var single = {};\n\t      single.type = g.type.replace('Multi','');\n\t      single.coordinates = part;\n        if(g.crs) single.crs = g.crs;\n\t      return single;\n\t    });  \n\t  } else {\n\t    return false;\n\t  }\n\t}\n\tfunction implode(gs) {\n\t  var sameType = gs.every(function(g) { \n\t    return singles.indexOf(g.type) > -1;\n\t  })\n    var crs = gs[0].crs || 0;\n    var sameCrs = gs.every(function(g) {\n      var gcrs = g.crs || 0;\n      return gcrs == crs;\n    });\n\t  if(sameType && sameCrs) {\n\t    var multi = {};\n\t    multi.type = 'Multi' + gs[0].type;\n\t    multi.coordinates = [];\n      if(crs != 0) multi.crs = crs;\n\t    gs.forEach(function(g) {\n\t      multi.coordinates.push(g.coordinates);\n\t    });\n\t    return multi;\n\t  } else {\n\t    return false;\n\t  }\n\t};\n\tvar multigeojson = {\n\t  explode: explode,\n\t  implode: implode\n\t};\n\tif(typeof module !== 'undefined' && module.exports) {\n\t  module.exports = multigeojson;\n\t} else if(window) {\n\t  window.multigeojson = multigeojson;\n\t}\n})();\n",
    "//converter.js\nvar multi = require('multigeojson');\n\nfunction getCoordString (coords, res, origin, opt) {\n  //origin - svg image origin\n  var coordStr = coords.map(function (coord) {\n    if (opt.project) {\n      coord = opt.project(coord);\n    }\n\n    var x = (coord[0] - origin.x) / res;\n    var y = (opt.yDirection || 1) * (origin.y - coord[1]) / res;\n\n    return x + ',' + y;\n  });\n\n  return coordStr.join(' ');\n}\n\nfunction addAttributes (ele, attributes) {\n  var part = ele.split('/>')[0];\n\n  for (var key in attributes) {\n    if (attributes.hasOwnProperty(key)) {\n      part += ' ' + key + '=\"' + attributes[key] + '\"';\n    }\n  }\n\n  return part + ' />';\n}\n\nfunction point (geom, res, origin, opt) {\n  var r = opt && opt.r ? opt.r : 1;\n  var pointAsCircle = opt && opt.hasOwnProperty('pointAsCircle') ? opt.pointAsCircle : false;\n  var coords = getCoordString([geom.coordinates], res, origin, opt);\n\n  if (pointAsCircle) {\n    return [coords];\n  } else {\n    return [\n      'M' + coords\n      + ' m' + -r + ',0' + ' a' + r + ',' + r + ' 0 1,1 ' + 2 * r + ',' + 0\n      + ' a' + r + ',' + r + ' 0 1,1 ' + -2 * r + ',' + 0\n    ];\n  }\n}\n\nfunction multiPoint (geom, res, origin, opt) {\n  var explode = opt && opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function (single) {\n    return point(single, res, origin, opt)[0];\n  });\n\n  if (!explode) return [paths.join(' ')];\n\n  return paths;\n}\n\nfunction lineString (geom, res, origin, opt) {\n  var coords = getCoordString(geom.coordinates, res, origin, opt);\n  var path = 'M' + coords;\n\n  return [path];\n}\n\nfunction multiLineString (geom, res, origin, opt) {\n  var explode = opt && opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function (single) {\n    return lineString(single, res, origin, opt)[0];\n  });\n\n  if (!explode) return [paths.join(' ')];\n\n  return paths;\n}\n\nfunction polygon (geom, res, origin, opt) {\n  var mainStr, holes, holeStr;\n\n  mainStr = getCoordString(geom.coordinates[0], res, origin, opt);\n\n  if (geom.coordinates.length > 1) {\n    holes = geom.coordinates.slice(1, geom.coordinates.length);\n  }\n\n  var path = 'M' + mainStr;\n\n  if (holes) {\n    for (var i = 0; i < holes.length; i++) {\n      path += ' M' + getCoordString(holes[i], res, origin, opt);\n    }\n  }\n\n  path += 'Z';\n\n  return [path];\n}\n\nfunction multiPolygon (geom, res, origin, opt) {\n  var explode = opt.hasOwnProperty('explode') ? opt.explode : false;\n  var paths = multi.explode(geom).map(function (single) {\n    return polygon(single, res, origin, opt)[0];\n  });\n\n  if (!explode) return [paths.join(' ').replace(/Z/g, '') + 'Z'];\n\n  return paths;\n}\n\nmodule.exports = {\n  Point: point,\n  MultiPoint: multiPoint,\n  LineString: lineString,\n  MultiLineString: multiLineString,\n  Polygon: polygon,\n  MultiPolygon: multiPolygon\n};\n",
    "// extend.js\n// extend b to a with shallow copy\nmodule.exports = function (a, b) {\n  var c = {};\n\n  Object.keys(a).forEach(function (key) {\n    c[key] = a[key]\n  });\n\n  Object.keys(b).forEach(function (key) {\n    c[key] = b[key]\n  });\n\n  return c;\n};\n",
    "var extend = require('./extend.js');\nvar converter = require('./converter.js');\n\n//g2svg as geojson2svg (shorthand)\nvar g2svg = function (options) {\n  this.options = options || {};\n  this.viewportSize = this.options.viewportSize || { width: 256, height: 256 };\n  this.mapExtent = this.options.mapExtent || {\n    left: -20037508.342789244,\n    right: 20037508.342789244,\n    bottom: -20037508.342789244,\n    top: 20037508.342789244\n  };\n\n  this.res = this.calResolution(this.mapExtent, this.viewportSize, this.options.fitTo);\n};\n\ng2svg.prototype.calResolution = function (extent, size, fitTo) {\n  var xres = (extent.right - extent.left) / size.width;\n  var yres = (extent.top - extent.bottom) / size.height;\n\n  if (fitTo) {\n    if (fitTo.toLowerCase() === 'width') {\n      return xres;\n    } else if (fitTo.toLowerCase() === 'height') {\n      return yres;\n    } else {\n      throw new Error('\"fitTo\" option should be \"width\" or \"height\"');\n    }\n  } else {\n    return Math.max(xres, yres);\n  }\n};\n\ng2svg.prototype.convert = function (geojson, options) {\n  var opt = extend(this.options, options || {});\n  var multiGeometries = ['MultiPoint', 'MultiLineString', 'MultiPolygon'];\n  var geometries = ['Point', 'LineString', 'Polygon'];\n  var svgElements = [];\n\n  if (geojson.type === 'FeatureCollection') {\n    for (var i = 0; i < geojson.features.length; i++) {\n      svgElements = svgElements.concat(this.convertFeature(geojson.features[i], opt));\n    }\n  } else if (geojson.type === 'Feature') {\n    svgElements = this.convertFeature(geojson, opt);\n  } else if (geojson.type === 'GeometryCollection') {\n    for (var i = 0; i < geojson.geometries.length; i++) {\n      svgElements = svgElements.concat(this.convertGeometry(geojson.geometries[i], opt));\n    }\n  } else if (converter[geojson.type]) {\n    svgElements = this.convertGeometry(geojson, opt);\n  } else {\n    return;\n  }\n\n  if (opt.callback) opt.callback.call(this, svgElements);\n\n  return svgElements;\n};\n\ng2svg.prototype.convertFeature = function (feature, options) {\n  if (!feature && !feature.geometry) return;\n\n  var opt = extend(this.options, options || {});\n\n  if (opt.attributes && opt.attributes instanceof Array) {\n    var arr = opt.attributes;\n\n    opt.attributes = arr.reduce(function (sum, property) {\n      if (typeof (property) === 'string') {\n        var val, key = property.split('.').pop();\n\n        try {\n          val = valueAt(feature, property)\n        } catch (e) {\n          val = false\n        }\n\n        if (val) sum[key] = val\n      } else if (typeof (property) === 'object' && property.type && property.property) {\n        if (property.type === 'dynamic') {\n          var val, key = property.key ? property.key : property.property.split('.').pop();\n\n          try {\n            val = valueAt(feature, property.property)\n          } catch (e) {\n            val = false\n          }\n\n          if (val) sum[key] = val\n        } else if (property.type === 'static' && property.value) {\n          sum[property.property] = property.value\n        }\n      }\n\n      return sum\n    }, {})\n  } else {\n    opt.attributes = opt.attributes || {};\n  }\n\n  var id = opt.attributes.id || feature.id || (feature.properties && feature.properties.id ? feature.properties.id : null);\n\n  if (id) opt.attributes.id = id;\n\n  return this.convertGeometry(feature.geometry, opt);\n};\n\ng2svg.prototype.convertGeometry = function (geom, options) {\n  if (converter[geom.type]) {\n    var opt = extend(this.options, options || {});\n    var output = opt.output || 'svg';\n    var paths = converter[geom.type].call(this, geom, this.res, { x: this.mapExtent.left, y: this.mapExtent.top }, opt);\n    var svgJsons, svgEles;\n\n    if (output.toLowerCase() === 'svg') {\n      svgJsons = paths.map(function (path) {\n        return pathToSvgJson(path, geom.type, opt.attributes, opt);\n      });\n\n      svgEles = svgJsons.map(function (json) {\n        return jsonToSvgElement(json, geom.type, opt);\n      });\n\n      return svgEles;\n    }\n\n    return paths;\n  }\n};\n\nfunction pathToSvgJson (path, type, attributes, opt) {\n  var svg = {};\n  var pointAsCircle = opt && opt.hasOwnProperty('pointAsCircle') ? opt.pointAsCircle : false;\n\n  if ((type === 'Point' || type === 'MultiPoint') && pointAsCircle) {\n    svg['cx'] = path.split(',')[0];\n    svg['cy'] = path.split(',')[1];\n    svg['r'] = opt && opt.r ? opt.r : '1';\n  } else {\n    svg = { d: path };\n    if (type === 'Polygon' || type === 'MultiPolygon') {\n      svg['fill-rule'] = 'evenodd';\n    }\n  }\n\n  for (var key in attributes) {\n    svg[key] = attributes[key];\n  }\n\n  return svg;\n};\n\nfunction jsonToSvgElement (json, type, opt) {\n  var pointAsCircle = opt && opt.hasOwnProperty('pointAsCircle') ? opt.pointAsCircle : false;\n  var ele = '<path';\n\n  if ((type === 'Point' || type === 'MultiPoint') && pointAsCircle) {\n    ele = '<circle';\n  }\n\n  for (var key in json) {\n    ele += ' ' + key + '=\"' + json[key] + '\"';\n  }\n\n  ele += '/>';\n\n  return ele;\n}\n\nfunction valueAt (obj, path) {\n  //taken from http://stackoverflow.com/a/6394168/713573\n  function index (prev, cur, i, arr) {\n    if (prev.hasOwnProperty(cur)) {\n      return prev[cur];\n    } else {\n      throw new Error(arr.slice(0, i + 1).join('.') + ' is not a valid property path');\n    }\n  }\n\n  return path.split('.').reduce(index, obj);\n}\n\nmodule.exports = g2svg;\n",
    "var g2svg = require('./instance.js');\n\nmodule.exports = function (options) {\n  return new g2svg(options);\n};\n"
  ]
}